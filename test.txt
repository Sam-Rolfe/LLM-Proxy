                    printf("New Connection Inbound\n");
                    client_server_t* cs = malloc(sizeof(client_server_t));
                    cs->client_read = true;
                    cs->invalid = false;
                    /* Potential client local variables */
                    
                    cs->client_addr_len = sizeof(cs->client_addr);



                    cs->client_fd = accept(p->listening_fd,
                                        (struct sockaddr*)&(cs->client_addr),
                                        &(cs->client_addr_len));

                    // struct sockaddr_in client_addr;
                    // unsigned int len = sizeof(client_addr);
                    // SSL *ssl;

                    char server_cert_file[HOST_NAME_LENGTH] = {0};
                    char server_key_file[HOST_NAME_LENGTH] = {0};
                    

                    cs->client_fd = accept(p->listening_fd, (struct sockaddr*)&(cs->client_addr), &(cs->client_addr_len));
                    if (cs->client_fd < 0) {
                        perror("Unable to accept");
                        exit(EXIT_FAILURE);
                    }
                    printf("Client TCP handshake successful\n");
                    // Receive client data
                    char request[BUFSIZE];
                    char hostname[100];
                    int bytes_received = recv(cs->client_fd, request, sizeof(request)-1, 0);
                    printf("Bytes received: %d\n", bytes_received);
                    printf("Message: %s\n", request);
                    extract_hostname(request, hostname);
                    printf("Hostname: %s\n", hostname);

                    // Client expects "Connection Established" response to CONNECT request.
                    // Must be sent for client to initiate SSL handshake
                    if (strstr(request, "CONNECT") == request) {
                        // Respond with "HTTP/1.1 200 Connection Established"
                        const char *response = "HTTP/1.1 200 Connection Established\r\n\r\n";
                        send(cs->client_fd, response, strlen(response), 0);
                        printf("Sent response to client:\n%s\n", response);

                        // Create server certificate and save to disk
                        create_server_certificate(root_cert_file, root_key_file, hostname, server_cert_file, server_key_file);
                        printf("\n--------------------\nCERTIFICATE CREATED\n--------------------\n\n");

                        // Prepare SSL Context object
                        cs->client_ctx = create_context();                                    // Get SSL Context to store TLS configuration parameters
                        printf("Context created\n");
                        configure_context(cs->client_ctx, server_cert_file, server_key_file); // Load certificate and private key into context
                        printf("Certificate loaded into context\n");

                        // Set client connection to SSL (perform SSL handshake)
                        cs->client_ssl = SSL_new(cs->client_ctx);      // Create SSL object
                        SSL_set_fd(cs->client_ssl, cs->client_fd);    // Link SSL object to accepted TCP socket
                        printf("SSL object created and linked to TCP socket\n");

                        if (SSL_accept(cs->client_ssl) <= 0) {        // Perform SSL handshake
                            printf("Unsuccessful client SSL handshake\n");
                            ERR_print_errors_fp(stderr);
                        } else {
                            printf("SSL handshake completed.\n");
                        }
                        /* DONE WITH SSL CONNECTION */
                        /* AT THIS POINT WE WANT TO GET INTO THE PARALLEL FACILOTATION */
                        /* RECIEVE NEXT MESSAGE */
                        bytes_received = SSL_read(cs->client_ssl, request, sizeof(request) - 1);
                        if (bytes_received > 0) {
                            request[bytes_received] = '\0'; // Null-terminate the received message
                            printf("Received message from client:\n %s\n\n", request);
                        } else {
                            printf("SSL_read failed");
                            exit(EXIT_FAILURE);
                        }

                        char request_copy[10000];
                        memcpy(request_copy, request, bytes_received);
                        header_elems* header = proxy_parse_header(request_copy);
                        print_header_elems(header);
                        printf("---------------\n");


                        /* receive a message from the client*/
                        printf("FORWARDING MESSAGE TO SERVER: %s", request);
                        cs->server_ctx = SSL_CTX_new(TLS_client_method());
                        cs->server_fd = open_connection(hostname, 443);
                        if (cs->server_fd < 0) {
                            fprintf(stderr, "Unable to connect to server\n");
                            exit(EXIT_FAILURE);
                        }
                        cs->server_ssl = create_ssl_connection(cs->server_ctx, cs->server_fd);

                        if (SSL_write(cs->server_ssl, request, bytes_received) <= 0) {
                            printf("ERROR with ssl_write\n");
                            exit(EXIT_FAILURE);
                        }

                        char* server_data;
                        int server_data_size;
                        char* server_header;
                        int server_header_size;
                        // proxy_read_server(ssl_server, 0, &server_data, 
                        //                 &server_data_size, &server_header, 
                        //                 &server_header_size, false);

                        // printf("SERVER HEADER:\n");
                        // printf("%.*s", server_header_size, server_header);

                        int bytes;
                        char server_response[10000] = {0};
                        bytes = SSL_read(cs->server_ssl, server_response, sizeof(server_response) - 1);
                        printf("HEADER\n%s\n", server_response);
                        if (SSL_write(cs->client_ssl, server_response, bytes) <= 0) {
                            printf("ERROR with ssl_write\n");
                            exit(EXIT_FAILURE);
                        }

                        bytes = SSL_read(cs->server_ssl, server_response, sizeof(server_response) - 1);
                        printf("RESPONSE\n%s\n", server_response);
                        if (SSL_write(cs->client_ssl, server_response, bytes) <= 0) {
                            printf("ERROR with ssl_write\n");
                            exit(EXIT_FAILURE);
                        }
                        printf("RESPONSE\n%s\n", server_response);




                        // Close SSL connection and free data structure
                        // SSL_shutdown(ssl);
                        // SSL_free(ssl);
                        proxy_add_cs(p, cs);
                    } else {
                        fprintf(stderr, "Invalid request: Not a CONNECT request\n");
                    }
                }